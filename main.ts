import {
  Project,
  ModuleDeclaration,
  SourceFile,
  ModuleDeclarationKind,
  CommentStatement,
  QuoteKind,
  IndentationText,
} from "https://deno.land/x/ts_morph@21.0.1/mod.ts";
import { OpenAPIV3, OpenAPIV3_1 } from "npm:openapi-types";

const METHODS = [
  "get",
  "put",
  "post",
  "delete",
  "options",
  "head",
  "patch",
  "trace",
] as const;

type Method = (typeof METHODS)[number];

export function resolveRef<T>(object: unknown, ref: string): T {
  if (!ref.startsWith("#/"))
    throw new TypeError("Only references which start with #/ are supported");

  const parts = ref.slice(2).split("/");
  let value = object as Record<string, T> | T;
  for (const part of parts) {
    if (typeof value !== "object")
      throw new TypeError(`Reference ${ref} has hit a non-traversable part`);
    if (value === null || value === undefined)
      throw new TypeError(`Reference ${ref} has hit a nullish part`);
    if (!(part in value))
      throw new TypeError(`Reference ${ref} does not exist`);

    value = (value as Record<string, T>)[part];
  }

  return value as T;
}

type Nullish<T> = T | null | undefined;

export function notEmpty<T>(value: Nullish<T>): value is T {
  switch (true) {
    case value === null || value === undefined || Number.isNaN(value):
      return false;
    case Array.isArray(value):
    case typeof value === "string":
      return Boolean((value as string | Array<T>).length);
    case typeof value === "object":
      return Boolean(Object.entries(value).length);
    default:
      return true;
  }
}

export function isOk(statusCode: number): boolean {
  return statusCode >= 200 && statusCode < 300;
}

class TypeFetch {
  document: OpenAPIV3.Document | OpenAPIV3_1.Document;
  project: Project;
  source: SourceFile;
  global: ModuleDeclaration;

  constructor(
    document: OpenAPIV3.Document | OpenAPIV3_1.Document,
    project: Project = new Project(),
    filePath: string = "./fetch.d.ts",
  ) {
    this.document = document;
    this.project = project;
    this.project.manipulationSettings.set({
      quoteKind: QuoteKind.Double,
      indentationText: IndentationText.TwoSpaces,
    });

    this.source ??= project.createSourceFile(filePath, undefined, {
      overwrite: true,
    });
    this.global = this.source.addModule({
      hasDeclareKeyword: true,
      declarationKind: ModuleDeclarationKind.Global,
      name: "global",
    });

    this.source.addImportDeclaration({
      isTypeOnly: true,
      moduleSpecifier: "./types/json.ts",
      namedImports: ["JSONString"],
    });
  }

  addComment() {
    this.source.insertStatements(0, (writer) => {
      writer.writeLine(
        `// This file was automatically generated by [TypeFetch](https://github.com/denosaurs/typefetch) at ${new Date().toISOString()}`,
      );
      writer.blankLine();

      writer.writeLine("/**");

      writer.writeLine(` * # ${this.document.info.title}`);

      if (notEmpty(this.document.info.description)) {
        writer.writeLine(" * ");
        writer.writeLine(
          ` * ${this.document.info.description.split("\n").join("\n * ")}`,
        );
      }

      if (
        "summary" in this.document.info &&
        notEmpty(this.document.info.summary)
      ) {
        writer.writeLine(` * @summary ${this.document.info.summary}`);
      }

      writer.writeLine(" * ");
      writer.writeLine(` * @version ${this.document.info.version}`);

      if (notEmpty(this.document.info.license?.name)) {
        writer.write(" * @license ");
        writer.writeLine(this.document.info.license.name);
      }

      if (notEmpty(this.document.info.contact?.name)) {
        writer.write(" * @author ");
        writer.write(this.document.info.contact.name);
        writer.spaceIfLastNot();
        writer.conditionalWrite(
          notEmpty(this.document.info.contact.email),
          `<${this.document.info.contact.email}>`,
        );
        writer.newLine();
      }

      writer.writeLine(" * @module");
      writer.writeLine(" */");
      writer.blankLine();
    });
  }

  addPathsObject() {
    for (const [pattern, item] of Object.entries(this.document.paths ?? {})) {
      this.addPathItem(pattern, item);
    }
  }

  addPathItem(
    pattern: string,
    item?: OpenAPIV3.PathItemObject | OpenAPIV3_1.PathItemObject,
  ) {
    if (item === undefined)
      throw new TypeError("OpenAPI path item object is required");

    const parameters = new Map();
    if (item.parameters) {
      for (let parameter of item.parameters) {
        if ("$ref" in parameter)
          parameter = resolveRef<OpenAPIV3_1.ParameterObject>(
            this.document,
            parameter.$ref,
          );
        parameters.set(parameter.name, parameter);
      }
    }

    for (const method of METHODS) {
      if (method in item) {
        const operation = item[method];
        this.addOperation(
          pattern,
          structuredClone(parameters),
          method,
          operation,
        );
      }
    }
  }

  addOperation(
    pattern: string,
    parameters: Map<
      string,
      OpenAPIV3.ParameterObject | OpenAPIV3_1.ParameterObject
    >,
    method: Method,
    operation?: OpenAPIV3.OperationObject | OpenAPIV3_1.OperationObject,
  ) {
    if (operation === undefined)
      throw new TypeError("OpenAPI operation object is required");

    if (operation.parameters) {
      for (let parameter of operation.parameters) {
        if ("$ref" in parameter)
          parameter = resolveRef<
            OpenAPIV3.ParameterObject | OpenAPIV3_1.ParameterObject
          >(this.document, parameter.$ref);
        parameters.set(parameter.name, parameter);
      }
    }

    if (operation.requestBody) {
      if ("$ref" in operation.requestBody)
        operation.requestBody = resolveRef<
          OpenAPIV3.RequestBodyObject | OpenAPIV3_1.RequestBodyObject
        >(this.document, operation.requestBody.$ref);

      for (const [contentType, object] of Object.entries(
        operation.requestBody.content,
      )) {
        let body = "BodyInit";

        switch (contentType) {
          case "application/json":
            body = `JSONString<${this.toSchemaType(object.schema)}>`;
            break;
          case "text/plain":
            body = "string";
            break;
          case "multipart/form-data":
            body = "FormData";
            break;
          case "application/x-www-form-urlencoded":
            body = "URLSearchParams";
            break;
          case "application/octet-stream":
            body = "ReadableStream | Blob | BufferSource";
            break;
        }

        const responseTypes: string[] = [];
        if (operation.responses !== undefined)
          for (let [statusString, response] of Object.entries<
            | OpenAPIV3.ResponsesObject[string]
            | OpenAPIV3_1.ResponsesObject[string]
          >(operation.responses)) {
            const status = Number(statusString);

            if ("$ref" in response)
              response = resolveRef<
                OpenAPIV3.ResponseObject | OpenAPIV3_1.ResponseObject
              >(this.document, response.$ref);
            if (response.content === undefined || response.content === null) {
              responseTypes.push(
                `{ ok: ${status >= 200 && status < 400 ? "true" : "false"}; status: ${status}; }`,
              );
              continue;
            }

            for (const [contentType, body] of Object.entries(
              response.content,
            )) {
              switch (contentType) {
                case "application/json":
                  responseTypes.push(
                    `{ ok: ${isOk(status) ? "true" : "false"}; status: ${status}; json(): Promise<${this.toSchemaType(body.schema)}>; text(): Promise<JSONString<${this.toSchemaType(body.schema)}>>; }`,
                  );
                  break;
                case "text/plain":
                  responseTypes.push(
                    `{ ok: ${isOk(status) ? "true" : "false"}; status: ${status}; text(): Promise<string>; }`,
                  );
                  break;
                case "multipart/form-data":
                  responseTypes.push(
                    `{ ok: ${isOk(status) ? "true" : "false"}; status: ${status}; formData(): Promise<FormData>; }`,
                  );
                  break;
                case "application/octet-stream":
                  responseTypes.push(
                    `{ ok: ${isOk(status) ? "true" : "false"}; status: ${status}; arrayBuffer(): Promise<ArrayBuffer>; blob(): Promise<Blob>; }`,
                  );
                  break;
                default:
                  responseTypes.push(
                    `{ ok: ${isOk(status) ? "true" : "false"}; status: ${status}; }`,
                  );
                  break;
              }
            }
          }

        const tags = [];

        if (operation.deprecated === true) {
          tags.push({ tagName: "deprecated" });
        }

        if (notEmpty(operation.summary)) {
          tags.push({ tagName: `summary ${operation.summary}` });
        }

        this.global.addFunction({
          name: "fetch",
          docs: [
            {
              description: (writer) => {
                writer.conditionalWriteLine(
                  notEmpty(operation.description),
                  operation.description!,
                );
              },
              tags,
            },
          ],
          parameters: [
            {
              name: "input",
              type: `\`${this.toTemplateString(pattern, parameters)}\``,
            },
            {
              name: "init",
              hasQuestionToken: true,
              type: (writer) => {
                writer.write(
                  `Omit<RequestInit, "method" | "body" | "headers"> &`,
                );
                writer.block(() => {
                  writer.writeLine(`method: "${method.toUpperCase()}";`);

                  writer.write("body");
                  writer.conditionalWrite(
                    !(
                      operation.requestBody &&
                      "required" in operation.requestBody &&
                      operation.requestBody.required
                    ),
                    "?",
                  );
                  writer.write(`: ${body};`);
                  writer.newLine();

                  writer.write(
                    `headers: { "Content-Type": "${contentType}"; };`,
                  );
                });
              },
            },
          ],
          returnType: (writer) => {
            writer.write(
              `Promise<Omit<Response, "ok" | "status" | "arrayBuffer" | "blob" | "formData" | "json" | "text"> & (`,
            );
            writer.write(responseTypes.join("|"));
            writer.write(")>");
          },
        });
      }
    }
  }

  addComponents() {
    for (const [name, schema] of Object.entries(
      this.document.components?.schemas ?? {},
    )) {
      this.source.addTypeAlias({
        isExported: true,
        name,
        type: this.toSchemaType(schema) ?? "unknown",
      });
    }
  }

  toTemplateString(
    pattern: string,
    parameters: Map<string, OpenAPIV3_1.ParameterObject>,
  ) {
    let patternTemplateString = pattern;

    for (const parameter of parameters.values()) {
      if (parameter.in !== "path") continue;

      patternTemplateString = patternTemplateString.replace(
        `{${parameter.name}}`,
        `\${${this.toSchemaType(parameter.schema) ?? "string"}}`,
      );
    }

    return patternTemplateString;
  }

  toSchemaType(
    schema?:
      | OpenAPIV3.ReferenceObject
      | OpenAPIV3.SchemaObject
      | OpenAPIV3_1.SchemaObject,
  ): string | undefined {
    if (schema === undefined) return undefined;
    if ("$ref" in schema) return schema.$ref.split("/").pop();

    if ("nullable" in schema && schema.nullable !== undefined) {
      const type = this.toSchemaType({ ...schema, nullable: undefined });
      if (type !== undefined) return `${type}|null`;
      return "null";
    }

    if (schema.not !== undefined) {
      const type = this.toSchemaType({ ...schema, not: undefined });
      const exclude = this.toSchemaType(schema.not);
      if (type !== undefined && exclude !== undefined)
        return `Exclude<${type}, ${exclude}>`;
      if (type !== undefined) return type;
      return undefined;
    }

    if (schema.additionalProperties) {
      const type = this.toSchemaType({
        ...schema,
        additionalProperties: undefined,
      });
      let additionalProperties;
      if (schema.additionalProperties !== true) {
        additionalProperties = this.toSchemaType(schema.additionalProperties);
      }
      if (type !== undefined)
        return `${type}&${additionalProperties ?? "Record<string, unknown>"}`;
      return undefined;
    }

    if (schema.allOf) {
      return schema.allOf
        .map((schema) => this.toSchemaType(schema))
        .filter(Boolean)
        .join("&");
    }

    if (schema.oneOf) {
      return schema.oneOf
        .map((schema) => this.toSchemaType(schema))
        .filter(Boolean)
        .join("|");
    }

    if (schema.anyOf) {
      console.warn(schema);
      console.warn(
        "Usage of anyOf operator with is not converted to the equivalent TypeScript type",
      );
      return schema.anyOf
        .map((schema) => this.toSchemaType(schema))
        .filter(Boolean)
        .join("|");
    }

    if (schema.enum) {
      return schema.enum.map((value) => JSON.stringify(value)).join("|");
    }

    switch (schema.type) {
      case "boolean":
        return "boolean";
      case "string":
        return "string";
      case "number":
      case "integer":
        return "number";
      case "object": {
        if ("properties" in schema && schema.properties !== undefined) {
          return `{${Object.entries(schema.properties)
            .map(([property, type]) => `${property}:${this.toSchemaType(type)}`)
            .join(";")}}`;
        }
        return "Record<string, unknown>";
      }
      case "array": {
        const items = this.toSchemaType(schema.items);
        if (items !== undefined) return `${items}[]`;
        return "unknown[]";
      }
      case "null":
        return "null";
    }

    return undefined;
  }
}

const openapi = (await import("./deno.json", { with: { type: "json" } }))
  .default as unknown as OpenAPIV3_1.Document;
const t = new TypeFetch(openapi, new Project());

t.addComment();
t.addComponents();
t.addPathsObject();

await t.source.save();
